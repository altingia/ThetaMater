---
title: 'ThetaMater: Rapid and scalable Bayesian estimation of theta from genomic data'
author: "Rich Adams, Drew Schield, Daren Card, Andrew Corbin, and Todd Castoe"
date: 'last updated: `r Sys.Date()`'
output:
  html_document:
    toc: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{ThetaMater tutorial} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## The population size parameter *$\theta=4N_e\mu$* 
The population size parameter *$\theta=4N_e\mu$* reflects the effects of genetic drift and mutation on patterns of genetic variation within a diploid population ( for a haploid population) with an effective size of $N_e$ individuals and a mutation rate of $\mu$ per site per generation. If two homologous sequences are sampled at random from a population, $\theta$ describes the expected number of mutations between these two sequences. $\theta$ is a fundamental measure of genetic diversity in populations and is thus an informative parameter used in many population genetic models. The R package ThetaMater provides a Bayesian framework to estimate both  and  (shape of among-locus rate variation) parameters from a variety of genetic datasets, including haploid or diploid genomic data from single or multiple individuals, reduced-representation genomic data (e.g., RADseq, sequence capture), and single or multilocus Sanger sequence data (and variations of these datasets). ThetaMater implements three different functions that can be used to estimate these parameters within a Bayesian framework:  
 * `ThetaMater.M1`: estimate $\theta$ without among-locus variation  
 * `ThetaMater.M2`: estimate $\theta$ with a fixed $\alpha$ parameter of rate variation and a user-defined number of rate classes  
 * `ThetaMater.M3`: estimate both $\theta$ and the shape parameter $\alpha$ and a user-defined number of rate classes  

## The likelihood function implemented by ThetaMater
The three functions (`ThetaMater.M1`, `ThetaMater.M2`, `ThetaMater.M3`) simulate posterior distributions of  and/or  parameters for a given dataset. These functions employ the likelihood function  ($P(S = k|l, n; \theta)$) to compute the probability of observing k mutations in a sample size of n from a locus with length l. These methods compute the likelihood of a given dataset as a summation of the log-likelihood probabilities across all loci, each with respective lengths, mutation counts, and sample sizes. See the following publications for more information about this model, its derivation, applications, and other similar models:  
* Tavar√©, Simon. "Line-of-descent and genealogical processes, and their applications in population genetics models." Theoretical population biology 26.2 (1984): 119-164.  
* Watterson,G.A. (1975) On the number of segregating sites in genetical models without recombination. Theor. Popul. Biol.  
* Wakeley, John. "Coalescent theory." Roberts & Company (2009).  
* Hein, Jotun, Mikkel Schierup, and Carsten Wiuf. Gene genealogies, variation and evolution: a primer in coalescent theory. Oxford University Press, USA, 2004.  
* Takahata, Naoyuki, and Yoko Satta. "Evolution of the primate lineage leading to modern humans: phylogenetic and demographic inferences from DNA sequences." Proceedings of the National Academy of Sciences 94.9 (1997): 4811-4815.  
* Takahata, Naoyuki, Yoko Satta, and Jan Klein. "Divergence time and population size in the lineage leading to modern humans." Theoretical population biology 48.2 (1995): 198-221. 
* Yang, Ziheng. "On the estimation of ancestral population sizes of modern humans." Genetical research 69.02 (1997): 111-116.  


Below is the formula for the likelihood function described in these papers that is central to the three ThetaMater functions:   
$P(S = k|l, n; \theta) = \int_0^{\infty}P(S=k|t)f_T(t)dt$  
$P(S = k|l, n; \theta) = (l\theta/2)\sum_{i=2}^n(-1)^i choose(n-1,i-1) (i-1)/2 \int_0^{\infty}(t^k e^(-l\theta-1)/2/k! dt)$  
$P(S = k|l, n; \theta) = (l\theta/2)^k \sum_{i=2}^n (-1)^i choose(n-1, i-1)(i-1)/2  (2/(l\theta+i-1)^(k+1)$  
$P(S = k|l, n; \theta) = \sum_{i=2}^n (-1)^i choose(n-1,i-1) ((i-1)/(l\theta+i-1)) ((l\theta)/(l\theta+i-1))^k$  

For a dataset consisting of $x$ loci, each with mutation count $k_i$, number of bases $l_i$, and number of sequences sampled $n_i$, we can sum the likelihoods of the individual loci to get the likelihood of the entire dataset under a given value of $\theta$:  
$L(D|\theta) = \sum_{i=1}^x log(P(S = k_i|l_i, n_i; \theta)$  

As estimates from any one locus entail significant uncertainity, ThetaMater allows researchers to take full advantage of large, diverse datasets when estimating $\theta$ and providing a distribution of plausible values while accounting for uncertainty.  

## Step 1: install R package ThetaMater from github

The R package ThetaMater is freely available to download and distribute from github <https://github.com/radamsRHA/ThetaMater/>. To install and load ThetaMater, you must first install the R packages `devtools`, `MCMCpack`, `phangorn`and `ape`.

```{r eval = FALSE}
# download dependencies
install.packages("devtools")
install.packages("MCMCpack")
install.packages("ape")
install.packages("phangorn")
```

Now using devtools we can install `ThetaMater` from github:
```{r eval = F, message = F}
library(devtools)
install_github("radamsRHA/ThetaMater")
```

Next, load the dependency packages for ThetaMater into the R working environment with the following code:
```{r eval = T, message=F}
library(ThetaMater) # Load package
library(MCMCpack) # Load dependency phybase
library(ape) # Load dependency ape
library(phangorn) # Load dependency phangorn
```

## Step 2: Functions to read input data formats and convert into infinite-sites data used by ThetaMater

ThetaMater currently includes a set of 5 functions to import the following widely-used data formats and convert these into the infinite sites format used by ThetaMater:   
 * Fasta alignments: a directory containing a set of fasta alignments. This can include any number of datatypes, provided they are in fasta format (i.e., Sequence capture, RADseq, Sanger sequenced, multilocus data, whole-genome alignments)  
 * Nexus alignments: a directory containing a set of nexus alignments. This can include any number of datatypes, provided they are in nexus format (i.e., Sequence capture, RADseq, Sanger sequenced, multilocus data, whole-genome alignments)  
 * pYRAD output alignments: a single, multilocus alleles file produced by the pyRAD pipeline  
 * Interleaved fasta alignments: a single, multilocus fasta file comprising multiple independent loci (i.e., similar to stacks output)  
 * Diploid genome fasta alignments: a single fasta file representing a diploid sequence alignment in which SNPs are coded as ambiquities  

Please contact Rich Adams (radams@uta.edu) to request additional formats that are not currently supported (provide a short example file to be used for building a custom function). The format for the input conversion functions arguments are as follows: 

`Read.FastaDir(fasta.dir)`  
 * `fasta.dir`: path to the directory of fasta alignments, each with a suffix of .fasta or .fa

`Read.NexusDir(nexus.dir)`  
 * `nexus.dir`: path to the directory of nexus alignments, each with a suffix of .nexus or .nex
 
`Read.AllelesFile(alleles.file)`  
 * `alleles.file`: path to the .alleles file provided by the pyRAD pipeline

`Read.InterleavedFasta(fasta.file)`  
 * `fasta.file`: path to an 'interleaved' fasta file (i.e., Stacks output)

`Read.DiploidFasta(genome.fasta.file)`  
 * `genome.fata.file`: path to a diploid genome fasta alignment (ambiquities code for SNPs)

Below we read one of the example datasets used in this tutorial:
```{r eval = TRUE}

# Load the example data provided with the package
data(example.dat,package= "ThetaMater")

# Let's look at the data
example.dat$k.vec # mutation counts
example.dat$l.vec # locus lengths
example.dat$n.vec # number of samples
example.dat$c.vec # number of observations (i.e., sum(example.dat$c.vec) = number of loci)
```

```{r eval = TRUE}
library(ThetaMater)
# To use the function 'Read.AllelesFile' you can try loading the raw file included with this package
file.loc <- system.file("example.alleles", package="ThetaMater")
example.dat <- Read.AllelesFile(alleles.file = file.loc)
```

Here, the object 'example.dat' returns a list with the following vectors:  
 * k.vec = vector of mutation counts  
 * l.vec = vector of locus lengths  
 * n.vec = vector of sample counts  
 * c.vec = vector of unique pattern counts  

## Step 3: Setting the prior distributions for $\theta$ and/or $\alpha$

ThetaMater uses gamma distributions to model the prior probabilty distributions for both $\theta$ and $\alpha$. The prior gamma distribution for $\theta$ and $\alpha$ are described by two parameters (shape and scale, with expectation[parameter] = shape*scale). These parameters should be set to reflect prior knowledge about $\theta$ and $\alpha$ before analyzing the observed dataset. In practice, we find that most theta values are within the range 0.00001-0.01. You can use the code below to view the gamma distribution prior to running ThetaMater:  
```{r}
# Lets see some gamma distribution settings for theta. 

# Here we have a relatively peaked prior with the expectation (shape * scale) = 0.001
shape = 10
scale = 0.0001

# See expected theta
E.theta = shape*scale 
E.theta

# Now let's plot this distribution
curve( dgamma(x,shape = shape,scale = scale), xlim=c(0,.01), xlab = "theta")

# Here's a prior for ~order of magnitude smaller than before
shape = 3
scale = 0.0001

# See expected theta
E.theta = shape*scale 
E.theta

curve( dgamma(x,shape = 3,scale = 0.0001), xlim=c(0,.01), xlab = "theta")

# Finally, here's an array of different settings for the prior
curve( dgamma(x,shape = 10,scale = 0.0001), xlim=c(0,0.01), xlab = "theta")
curve( dgamma(x,shape = 30, scale =0.0001), add=T, col='red' )
curve( dgamma(x,shape = 3,scale = 0.001), add=T, col='green' )
curve( dgamma(x,shape = 1,scale = 0.001), add=T, col='blue' )
curve( dgamma(x,shape = 10, scale = 0.001), add=T, col='orange' )
title(main="Gamma probability distribution function")
legend(par('usr')[2], par('usr')[4], xjust=1,
			 c('shape = 10, scale = 0.00001, E[theta] = 0.001', 'shape = 30, scale = 0.0001, E[theta] = 0.003', 
			 	'shape = 3, scale = 0.001, E[theta] = 0.003', 'shape = 1, scale = 0.001, E[theta] = 0.001', 'shape = 10, scale = 0.001, E[theta] = 0.01'),
			 lwd=1, lty=1,
			 col=c(par('fg'), 'red', 'green', 'blue', 'orange') )
```

The shape and scale parameters can be set for $\alpha$ in a similar manner to reflect prior knowledge about the distributon of among-locus rate variation in your dataset. 

***IMPORTANT: The prior distribution is designed to reflect prior knowledge about the parameters before viewing the dataset. For example, one can set the shape and scale parameters of the prior to reflect an expected value provided from previous datasets. It is reasonable to try different sets of prior values to determine the sensitivty of the posterior to the prior and to evaluate the results under different settings. ***  

## Step 4.1: `ThetaMater.M1`: function to simulate a posterior distribution of theta without among-locus rate variation

Here we will estimate Theta for the given dataset using ThetaMater.M1. The input arguments for the function `ThetaMater.M1` are as follows:

`ThetaMater.M1(k.vec, l.vec, n.vec, c.vec, ngens, burnin, thin, theta.shape, theta.scale)`  
 * `k.vec`: vector of mutation counts  
 * `l.vec`: vector of locus lengths  
 * `n.vec`: vector of sample counts  
 * `c.vec`: vector of unique pattern counts  
 * `ngens`: number of iterations to run the MCMC simulation  
 * `burnin`: number of iterations to discard as burnin  
 * `thin`: number of iterations between recorded MCMC samples  
 * `theta.shape`: shape parameter of the prior gamma distribution on theta (See Step 2)  
 * `theta.scale`: scale parameter of the prior gamma distribution on theta (See Step 2)  

Before estimating $\theta$ with ThetaMater.M1, let's first view and set the prior distribution for $\theta$ that we will use in this example analysis. These data were simulated using theta = 0.002, and thus we set a prior distribution with an expectation of 0.002 for this example population. For empirical analyses, the values of these parameters (theta.shape, theta.scale) will be ideally set to reflect prior knowledge about a given population under study. For this analysis will set `theta.shape` and `theta.scale` as the following:
```{r eval = TRUE}
shape = 2
scale = 0.001
E.theta = shape*scale 
E.theta
```

Let's go ahead and plot this distribution to visualize our prior (See Step 3 for more information on setting priors):
```{r eval = TRUE}
curve( dgamma(x,shape = 2,scale = 0.001), xlim=c(0,.01), xlab = "theta")
```

Now we are ready to estimate $\theta$ We can load the example data and run the MCMC for ThetaMater.M1 using the code below:

```{r eval = T}
data(example.dat,package= "ThetaMater")

example.MCMC <- ThetaMater.M1(k.vec = example.dat$k.vec, l.vec = example.dat$l.vec, n.vec = example.dat$n.vec, c.vec = example.dat$c.vec, ngens = 50, burnin = 1, theta.shape = shape, theta.scale = scale, thin = 2)
```

We didn't run the mcmc very long, and thus the MCMC output does not appear at stationarity. See trace and density plot of the posterior below: 

```{r eval = T}
varnames(example.MCMC) <- "theta"
plot(example.MCMC)
```

Let's look at the results from a much longer run that was executed using the below command:

```{r eval = F}
example.MCMC <- ThetaMater.M1(k.vec = example.dat$k.vec, l.vec = example.dat$l.vec, n.vec = example.dat$n.vec, c.vec = example.dat$c.vec,ngens = 1000000, burnin = 1000, thin = 10, theta.shape = shape, theta.scale = scale)

```
```{r eval = T}
file.loc <- system.file("example.MCMC.M1.csv", package="ThetaMater")
plot(as.mcmc(read.csv(file = file.loc)))

```

As you can see from the trace and density plot, the MCMC has reached stationarity (represented by the classic "fuzzy caterpillar" shape). Also, we can look at the mean and variance of the posterior distribution of $\theta$ using this code below:

```{r eval = T}
file.loc <- system.file("example.MCMC.M1.csv", package="ThetaMater")
mean(as.mcmc(read.csv(file = file.loc))) # close to the simulated value of 0.002
sd(as.mcmc(read.csv(file = file.loc)))
summary(as.mcmc(read.csv(file = file.loc))) 

```


***IMPORTANT: Don't panic if you see this error when running ThetaMater: "initial value in 'vmmin' is not finite". This just means that the likelihood of the data is very small under the current prior settings and thus 'infinite' likelihood values may arise. Thus, the likelihood function used by ThetaMater may react poorly to badly specified prior values for $\theta$. If you see this error when running ThetaMater, try different prior settings and multiple runs. See below commands for a demonstration. As always, contact the author (radams@uta.edu) if you need further guidance with setting priors for your dataset.***  


```{r, echo=T, message=F, warning=T, error= T}
# Here's a poorly specified prior that is far from the true value (this will give the error)
example.MCMC <- ThetaMater.M1(k.vec = example.dat$k.vec, l.vec = example.dat$l.vec, n.vec = example.dat$n.vec, c.vec = example.dat$c.vec,ngens = 500, burnin = 1, thin = 1, theta.shape = 10, theta.scale = 10)

# Let's try another prior setting that is closer to the true value of theta
example.MCMC <- ThetaMater.M1(k.vec = example.dat$k.vec, l.vec = example.dat$l.vec, n.vec = example.dat$n.vec, c.vec = example.dat$c.vec,ngens = 500, burnin = 1, thin = 1, theta.shape = 1, theta.scale = 1)
```

It works! No error this time. With better prior settings that are close to the true value, this likelihood function will not misbehave and the error will not occur. As always, contact the author Rich Adams (radams@uta.edu) if you have any questions and/or receive this error message.

## Step 4.2: `ThetaMater.M2`: function to simulate a posterior distribution of $\theta$ with a fixed shape parameter $\alpha$ of among-locus rate variation

Here we will estimate the posterior distribution of $\theta$ using a fixed $\alpha$ parameter describing the distribution of among-locus rate variation within our dataset. The input arguments for the function `ThetaMater.M2` are as follows:

`ThetaMater.M2(k.vec, l.vec, n.vec, c.vec, alpha, K.classes, ngens, burnin, thin, theta.shape, theta.scale)`
 * `k.vec`: vector of mutation counts  
 * `l.vec`: vector of locus lengths  
 * `n.vec`: vector of sample counts  
 * `c.vec`: vector of unique pattern counts  
 * `ngens`: number of generations to run the MCMC simulation  
 * `alpha`: fixed alpha parameter describing the shape of the distribution of among-locus rate variation    
 * `K.classes`: number of disctinct classes to approximate the gamma distribution (4-20 are commonly used for datasets)
 * `burnin`: number of generations to discard as burnin  
 * `thin`: number of generations between recorded MCMC samples  
 * `theta.shape`: shape parameter of the prior gamma distribution on $\theta$ (See Step 2)  
 * `theta.scale`: scale parameter of the prior gamma distribution on $\theta$ (See Step 2)  


The following example data were simulated using $\theta$ = 0.002 and $\alpha$ = 0.1 (using 4 rate classes to approximate the gamma distribution)
```{r eval = F}
data(example.M2.dat, package= "ThetaMater")
# Let's look at the data
example.M2.dat$k.vec # mutation counts
example.M2.dat$l.vec # locus lengths
example.M2.dat$n.vec # number of samples
example.M2.dat$c.vec # number of observations
```

Failure to account for among-locus rate variation can affect parameter estimates, such as $\theta$. So, let's see what happens when we do not account for among-locus rate variation (i.e., model misspecification). Here the data were generated under ThetaMater.M2, but we will first simulate posterior distributions of $\theta$ using ThetaMater.M1, which does not account for rate variation. 
```{r eval = F}
shape = 2
scale = 0.001

example.MCMC.M1.M2 <- ThetaMater.M1(k.vec = example.M2.data$k.vec, l.vec = example.M2.data$l.vec, n.vec = example.M2.data$n.vec, c.vec = example.M2.data$c.vec, theta.shape = shape, theta.scale = scale, ngens = 1000000, burnin = 100000, thin = 100)
```
The results from this 'model-misspecification' analysis are shown below:
```{r eval = T}
data(example.MCMC.M2,package= "ThetaMater")
mean(example.MCMC.M2)
varnames(example.MCMC.M2) <- "theta"
plot(as.mcmc(example.MCMC.M2))
```

In the above case, using `ThetaMater.M1` instead of the correct `ThetaMater.M2` (or `ThetaMater.M3`, see below) function lead to substantially lower estimates $\theta$ of  with a posterior distribution that is tightly peaked at $\theta$ = 0.0015.
So, let's use `ThetaMater.M2` to infer the posterior distribution of $\theta$ given $\alpha$ = 0.10 and k = 4.

```{r eval = F}
shape = 2
scale = 0.001

example.MCMC.M2 <- ThetaMater.M2(k.vec = example.M2.data$k.vec, l.vec = example.M2.data$l.vec, n.vec = example.M2.data$n.vec, c.vec = example.M2.data$c.vec, theta.shape = shape, theta.scale = scale, ngens = 1000000, burnin = 100000, thin = 100, K = 4, alpha.param = 0.1)
```

And here are the results from this analysis:
```{r eval = T}
data(example.MCMC.M2.M2,package= "ThetaMater")
mean(example.MCMC.M2.M2)
varnames(example.MCMC.M2.M2) <- "theta"
plot(as.mcmc(example.MCMC.M2.M2))
```


## Step 4.3: `ThetaMater.M3`: function to simulate a posterior distribution of $\theta$ and $\alpha$ 

Here we use `ThetaMater.M3` to estimate the joint posterior distribution of $\theta$ and $\alpha$ for our dataset.
The input arguments for the function `ThetaMater.M3` are as follows:  

`ThetaMater.M3(k.vec, l.vec, n.vec, c.vec, alpha, K.classes, ngens, burnin, thin, theta.shape, theta.scale, alpha.shape, alpha.scale)`  
 * `k.vec`: vector of mutation counts  
 * `l.vec`: vector of locus lengths  
 * `n.vec`: vector of sample counts  
 * `c.vec`: vector of unique pattern counts  
 * `ngens`: number of generations to run the MCMC simulation  
 * `K.classes`: number of diiscrete classes to approximate the gamma distribution (4-20 are commonly used)  
 * `burnin`: number of generations to discard as burnin  
 * `thin`: number of generations between recorded MCMC samples  
 * `theta.shape`: shape parameter of the prior gamma distribution on $\theta$ (See Step 2)  
 * `theta.scale`: scale parameter of the prior gamma distribution on $\theta$ (See Step 2)  
 * `alpha.shape`: shape parameter of the prior gamma distribution on $\alpha$ (See Step 2)  
 * `alpha.scale`: scale parameter of the prior gamma distribution on $\alpha$ (See Step 2)  

Notice: here we will set the prior distributions for both $\theta$ and $\alpha$ (theta.shape, theta.scale, alpha.shape, alpha.scale). Let's load the data from the previous analyses (Step 4.2, M2)

```{r eval = F}
data(example.M2.dat, package= "ThetaMater")
# Let's look at the data
example.M2.dat$k.vec # mutation counts
example.M2.dat$l.vec # locus lengths
example.M2.dat$n.vec # number of samples
example.M2.dat$c.vec # number of observations
```

Let's run these analysis using the command below:
```{r eval = FALSE}
example.MCMC.M3 <- ThetaMater.M3(k.vec = example.M2.dat$k.vec, l.vec = example.M2.dat$l.vec, n.vec = example.M2.dat$n.vec, c.vec = example.M2.dat$c.vec, K = 4, ngens = 1000000, burnin = 100000, thin = 10, theta.shape = theta.shape, theta.scale = theta.scale, alpha.shape = alpha.shape, alpha.scale = alpha.scale)

```

And here are the results from this run, with the posterior of $\theta$ on top and $\alpha$ on bottom

```{r eval = T}
data(example.MCMC.M3,package= "ThetaMater")
varnames(example.MCMC.M3) <- c("theta", "alpha")
plot(as.mcmc(example.MCMC.M3))
```

We can also make a nice 3D hexbin plot with colors indicating the number of MCMC steps in that state (i.e., warmer colors showing higher posterior probability):

```{r eval = T}
# See instructions at http://www.everydayanalytics.ca/2014/09/5-ways-to-do-2d-histograms-in-r.html
library(hexbin)
library(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
h <- hexbin(example.MCMC.M3)
plot(h, colramp=rf, xlab = "theta", ylab = "alpha")

```


## Step 5: Evaluating the results of a ThetaMater analysis

We can visualize/assess the results of MCMC runs under each model using the plotting function provided by MCMCpack. As discussed earlier, it is important to assess the MCMC mixing behavior to convergence on the posterior distribution. In this sense, we want to make sure the posterior sampled sufficient steps to reach the posterior distribution. Roughly speaking, we are looking for a 'fuzzy caterpillar' shape of the MCMC trace shown in the plots. These plots can be used to decide how many generations should be discarded as burnin; these are steps that are correlated with the initial state, and may not be accurate approximations to the true posterior. For example, the below MCMC analysis has yet to reach convergence and does not show the "fuzzy caterpillar" shape that is indicative of convergence to the posterior distribution.


```{r eval = T}
data(example.dat,package= "ThetaMater")

example.MCMC <- ThetaMater.M1(k.vec = example.dat$k.vec, l.vec = example.dat$l.vec, n.vec = example.dat$n.vec, c.vec = example.dat$c.vec, ngens = 50, burnin = 1, theta.shape = shape, theta.scale = scale, thin = 2)
varnames(example.MCMC) = "theta"
plot(example.MCMC)
```

Here's a much better mcmc run with many more steps sampled and adequate burnin, demonstrating the "fuzzy caterpillar" shape:
```{r eval = T}
file.loc <- system.file("example.MCMC.M1.csv", package="ThetaMater")
mean(as.mcmc(read.csv(file = file.loc))) # close to the simulated value of 0.002
sd(as.mcmc(read.csv(file = file.loc)))
plot(as.mcmc(read.csv(file = file.loc)))
```

Use the argument `ngens` to run the MCMC chain longer if your analysis has not yet converged to stationarity.

## Step 6: (Optional) Convert $\theta$ estimates into estimates of effective population size $N_e$

It is often desirable to convert estimates of $\theta$ into estimates of the true effective population size $N_e$. Giving an estimate of the mutation rate $\mu$, we can convert the posterior distriburion of $\theta$ into a posterior distribution of population $N_e$

$N_e = \theta/4\mu$

For example, let's assume our given population evolved under a mutation rate $\mu$ of 2.2*10^-8 (similar to human estimates). We simply take the results from ThetaMater and divide the vector of $\theta$ by this mutation rate multiplied by factor of 4 (or 2 for haploid data).

```{r eval = T}
# load the results from a ThetaMater analysis
data(example.MCMC.M3,package= "ThetaMater")
mutation.rate = 2.2*10^-8
example.MCMC.M3.Ne <- example.MCMC.M3
example.MCMC.M3.Ne[,1] = example.MCMC.M3.Ne[,1]/(mutation.rate*4)
h <- hexbin(example.MCMC.M3.Ne)
plot(h, colramp=rf, xlab = "Ne", ylab = "alpha")
```


## Step 7: (Optional) conduct posterior predictive simulation to remove loci with evidence of unlikely mutation counts (i.e., potential paralogs)

Finally, we can leverage the posterior distribution of $\theta$ that is estimated by ThetaMater to simulate posterior predictive simulated (PPS) distributions of mutation counts (k.vec) using the function ThetaMater.PPS. We can leaverage this PPS distribution filter out loci with unexpected mutation counts, such as incorrectly assembled paralogous loci, which will result in greater than expected numbers of single-locus ‚Äòmutations‚Äô. The commands for using the function ThetaMater.PPS are as follows:


`ThetaMater.PPS(theta.MCMC, l.vec, n.vec)`  
 * `l.vec`: vector of locus lengths  
 * `n.vec`: vector of sample counts  
 * `theta.MCMC`: Posterior distribution of theta inferred via ThetaMater

In this example, the PPS (white) and the observed (gray) distribution overlap considerably, and thus there is no need to filter out loci based on mutation counts alone
```{r eval = T}
data(example.dat,package= "ThetaMater")
file.loc <- system.file("example.MCMC.M1.csv", package="ThetaMater")
mcmc.results <- read.csv(file = file.loc) # close to the simulated value of
PPS.results <- ThetaMater.PPS(theta.MCMC = mcmc.results[,1], l.vec = example.dat$l.vec, n.vec = example.dat$n.vec)
hist(PPS.results, freq = F, breaks = 10)
hist(example.dat$k.vec, col="gray20",add=T, freq = F, breaks = 10)
```

Now, in this next sample we have a simulated dataset in which 4 paralogous loci (out of 1000) have been erronously placed into the same alignment, because they were  assumed to be homologous. Using the code below, we will load the ‚Äòexample.SeqError.alles‚Äô data into R and first estimate  using this unfiltered dataset.
 
```{r eval = T}
# Let's look at the mutation count vector
data(example.SeqError.alles,package= "ThetaMater")
example.SeqError.alles$k.vec
```
Next, we estimated $\theta$ using ThetaMater.M1 on this unfiltered dataset:
```{r eval = F}
mcmc.seq.error <- ThetaMater.M1(k.vec= example.SeqError.alles$k.vec, l.vec = example.SeqError.alles$l.vec, n.vec = example.SeqError.alles$n.vec, c.vec = example.SeqError.alles$c.vec, ngens = 100000, burnin = 10000, thin = 100, theta.shape = 2, theta.scale = 0.001)
```
And here are the results:
```{r eval = T}
data(example.MCMC.SequenceError, package = "ThetaMater")
varnames(example.MCMC.SequenceError) = "theta"
plot(as.mcmc(example.MCMC.SequenceError))
```

Now let's conduct PPS using ThetaMater.PPS and overlay the distributions to see if we can identiy the 4 outlier loci:
```{r eval = T}
# run PPS analysis using this command:
example.PPS.results <- ThetaMater.PPS(theta.MCMC = example.MCMC.SequenceError[,1], l.vec = example.SeqError.alles$l.vec, n.vec = example.SeqError.alles$n.vec)
hist(rep(example.SeqError.alles$k.vec, example.SeqError.alles$c.vec), col="gray20",add=F, freq = F, breaks = 100, main = "PPS vs Observed mutation counts", xlab = "mutation counts")
hist(example.PPS.results, freq = T, breaks = 10, add = T)
abline(v=6, col="red", lwd = 5)
```

Here the red line shows the maximum number of mutations observed in the PPS data. So, let's remove the four extreme loci that are beyond this value and reestimate $\theta$ after filtering using this PPS distribution
```{r eval = T}
max(example.PPS.results)
example.Filtered <- FilterData.PPS(dataset = example.SeqError.alles, threshold = 6)
```
Now, let's estimate $\theta$ after PPS filtering using the following commands:
```{r eval = F}
# Now let's estimate theta after PPS filtering
example.MCMC.PostFilter <- ThetaMater.M1(k.vec = example.Filtered$k.vec, l.vec = example.Filtered$l.vec, n.vec = example.Filtered$n.vec, c.vec = example.Filtered$c.vec, ngens = 100000, burnin = 10000, thin = 100, theta.shape = 2, theta.scale = 0.001)
```
And let's load these results below:
```{r eval = T}
data(example.MCMC.PostFilter, package = "ThetaMater")
varnames(example.MCMC.PostFilter) = "theta"
plot(as.mcmc(example.MCMC.PostFilter))
```